from __future__ import annotations
from typing import TYPE_CHECKING

from core.settings import Settings

if TYPE_CHECKING:
    from vertexai.generative_models._generative_models import GenerativeModel, GenerationResponse, Part
    from PIL import Image

class VertexAIClientError(Exception):
    pass

class VertexAIConfigurationError(VertexAIClientError):
    pass

def create_vertex_ai_model(settings: Settings) -> "GenerativeModel":
    if not settings.GCP_PROJECT_ID or not settings.GCP_LOCATION:
        raise VertexAIConfigurationError(
            "GCP project/location not configured. Set GCP_PROJECT_ID and GCP_LOCATION."
        )
    
    project_id = settings.GCP_PROJECT_ID
    location = settings.GCP_LOCATION

    try:
        import vertexai
        from vertexai.generative_models import GenerativeModel
    except ImportError as e:
        raise VertexAIClientError(f"Vertex AI SDK not available: {e}") from e

    try:
        vertexai.init(project=project_id, location=location)
        model = GenerativeModel(settings.VERTEX_IMAGE_MODEL)
        return model
    except Exception as e:
        raise VertexAIClientError(f"Vertex AI initialization failed: {e}") from e

def extract_image_bytes_from_part(part: "Part") -> bytes:
    if hasattr(part, "_raw_image_bytes") and part._raw_image_bytes:
        return part._raw_image_bytes

    if hasattr(part, "_image") and part._image:
        try:
            from PIL import Image
            import io
            if isinstance(part._image, Image.Image):
                buf = io.BytesIO()
                part._image.save(buf, format="PNG")
                return buf.getvalue()
        except ImportError:
            pass
    
    raise ValueError("Could not extract image bytes from the provided API Part object.")

def get_generation_failure_reason(response: "GenerationResponse") -> str:
    if not response.candidates:
        return "No candidates were generated by the model."

    candidate = response.candidates[0]
    reason = candidate.finish_reason.name
    
    if candidate.safety_ratings:
        safety_info = ", ".join(
            f"{rating.category.name}={rating.probability.name}"
            for rating in candidate.safety_ratings
        )
        return f"Finish Reason: {reason}, Safety Ratings: [{safety_info}]"
    
    return f"Finish Reason: {reason}"